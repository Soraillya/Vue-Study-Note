<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Vue Life</title>
        <script type="text/javascript" src="js/vue.js"></script>
        <!-- 生命周期（尝试用debugger去中断生命周期）
        
            1. beforeCreate: 初始化--生命周期、事件，但数据代理还未开始
                -- 此时 无法通过vm访问到data中的数据、methods中配置的方法

            2. created: 初始化--数据监测、数据代理
                -- 此时 可以通过vm访问到data中的数据、methods中配置的方法

            3. beforeMount: 此阶段Vue开始解析模板，生成虚拟DOM（内存中），页面还不能显示解析好的内容
                -- 此时 页面呈现的是未经Vue编译的DOM结构；所有对DOM的操作最终都不奏效

            4. mounted: Vue完成模板的解析并把真实的DOM元素放入页面后
                -- 此时 页面中呈现的是经过Vue编译的DOM；对DOM的操作均有效（不推荐而且避免，会显得Vue很呆），至此初始化过程结束，
                   一般在此进行：开启定时器、发送网络请求、订阅消息、绑定自定义时间 等等初始化操作

            5. beforeUpdate: vm中的data、methods等更新后、渲染到页面之前
                -- 此时 数据是最新的，但页面是旧的；即：页面尚未和数据保持同步
            
                5.5 从beforeUpdate -> updated：
                    根据新数据，生成新的虚拟DOM，随后与旧的虚拟DOM进行比较，最终完成页面的更新；即：完成了Model -> View的更新

            6. updated: vm中的data、methods等更新后、渲染到页面之后
                -- 此时 数据是最新的，页面也是最新的；即：页面和数据保持同步

            7. beforeDestroy: 执行销毁vm动作之前
                -- 此时 vm中所有的：data、methods、指令等等，都处于可用状态，马上要执行销毁过程
                   一般在此进行：关闭定时器、取消订阅消息、解绑自定义事件等收尾操作
            
            8. destroy: 销毁vm，清理它与其它实例的连接，解绑它的全部指令及事件监听器。但临死前的工作成果还在（真实DOM还在）
        -->
    </head>
    <body>
        <div id="root">
            <h2 :style="{opacity}">Hello World!!!</h2>
            <h2 :style="{opacity}">生命周期：又名生命周期回调函数、生命周期函数、生命周期钩子(hook，常用命名)</h2>
            <h2 :style="{opacity}">生命周期钩子的名字不可更改，但函数的具体内容由程序员根据需求编写</h2>
            <h2 :style="{opacity}">生命周期钩子中的this指向是vm或组件实例对象</h2>
            <h2 :style="{opacity}">1. mounted 挂载：Vue完成模板的解析并把真实的DOM元素放入页面后</h2>

            <h2 :style="{opacity}">1. beforeCreate: 初始化--生命周期、事件，但数据代理还未开始</h2>
            <h2 :style="{opacity}">-- 此时 无法通过vm访问到data中的数据、methods中配置的方法</h2>
            <h2 :style="{opacity}"></h2>
            <h2 :style="{opacity}">2. created: 初始化--数据监测、数据代理</h2>
            <h2 :style="{opacity}">-- 此时 可以通过vm访问到data中的数据、methods中配置的方法</h2>
            <h2 :style="{opacity}"></h2>
            <h2 :style="{opacity}">3. beforeMount: 此阶段Vue开始解析模板，生成虚拟DOM（内存中），页面还不能显示解析好的内容</h2>
            <h2 :style="{opacity}">-- 此时 页面呈现的是未经Vue编译的DOM结构；所有对DOM的操作最终都不奏效</h2>
            <h2 :style="{opacity}"></h2>
            <h2 :style="{opacity}">4. mounted: Vue完成模板的解析并把真实的DOM元素放入页面后</h2>
            <h2 :style="{opacity}">-- 此时 页面中呈现的是经过Vue编译的DOM；对DOM的操作均有效（不推荐而且避免，会显得Vue很呆），至此初始化过程结束，</h2>
            <h2 :style="{opacity}">一般在此进行：开启定时器、发送网络请求、订阅消息、绑定自定义时间 等等初始化操作</h2>
            <h2 :style="{opacity}"></h2>
            <h2 :style="{opacity}">5. beforeUpdate: vm中的data、methods等更新后、渲染到页面之前</h2>
            <h2 :style="{opacity}">-- 此时 数据是最新的，但页面是旧的；即：页面尚未和数据保持同步</h2>
            <h2 :style="{opacity}"></h2>
            <h2 :style="{opacity}">5.5 从beforeUpdate -> updated：</h2>
            <h2 :style="{opacity}">根据新数据，生成新的虚拟DOM，随后与旧的虚拟DOM进行比较，最终完成页面的更新；即：完成了Model -> View的更新</h2>
            <h2 :style="{opacity}"></h2>
            <h2 :style="{opacity}">6. updated: vm中的data、methods等更新后、渲染到页面之后</h2>
            <h2 :style="{opacity}">-- 此时 数据是最新的，页面也是最新的；即：页面和数据保持同步</h2>
            <h2 :style="{opacity}"></h2>
            <h2 :style="{opacity}">7. beforeDestroy: 执行销毁vm动作之前</h2>
            <h2 :style="{opacity}">-- 此时 vm中所有的：data、methods、指令等等，都处于可用状态，马上要执行销毁过程</h2>
            <h2 :style="{opacity}">一般在此进行：关闭定时器、取消订阅消息、解绑自定义事件等收尾操作</h2>
            <h2 :style="{opacity}"></h2>
            <h2 :style="{opacity}">8. destroy: 销毁vm，清理它与其它实例的连接，解绑它的全部指令及事件监听器。但临死前的工作成果还在（真实DOM还在）</h2>
        </div>
    </body>
    <script type="text/javascript">
        Vue.config.productionTip = false; //阻止 vue 在启动时生成生产提示
        const vm = new Vue({
            el: "#root",
            data: {
                opacity: 1,
            },
            methods: {
                change() {
                    setInterval(() => {
                        if (this.opacity <= 0) this.opacity = 1;
                        this.opacity -= 0.01;
                    }, 32);
                },
            },
            beforeCreate() {
                console.log("beforeCreate");
            },
            created() {
                console.log("created");
            },
            beforeMount() {
                console.log("beforeMount");
            },
            // Vue完成模板的解析并把真实的DOM元素放入页面后（挂载完毕）调用mounted，
            // 整个Vue的生命过程中指挂载一次
            // 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】
            // 重要
            mounted() {
                console.log("Vue start to mount!!!");
                this.change();
            },
            beforeUpdate() {
                console.log("beforeUpdate");
            },
            updated() {
                console.log("updated");
            },
            // 重要
            // 清楚定时器、解绑自定义事件、取消订阅消息等【收尾工作】
            beforeDestroy() {
                console.log("beforeDestroy");
            },
            // 关于销毁Vue实例
            // 1. 销毁后借助Vue开发者工具看不到任何消息
            // 2. 销毁后自定义事件会失效，但原生DOM事件依然有效
            // 3. 一般不会在beforeDestroy操作数据，因为即使操作数据，也不会触发更新流程了（beforeUpdate、updated）
            destroy() {
                console.log("destroy");
            },
        });

        // 通过外部window调用vm里的定时器？离谱！
        // window.onload(vm.change());
    </script>
</html>
